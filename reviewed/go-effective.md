# 如何高效写go代码

## 介绍

新语言，吸收了其他语言中的一些思想，但也不是和其他语言完全一样，
所以需要了解一些细节的设计.
effective go 是对spec/tour of go的扩充.

Go标准库,是核心库,同时也是语言使用的最好demo,
所以多看看Go源码是非常有必要的.

## 格式

使用gofmt格式化代码.

源码中的大部分格式都会被gofmt按标准进行处理,还是有少数格式会被保留:

- 缩进,gofmt使用tab缩进,使用空格不会被gofmt处理
- 行长度,Go对行长没有限制,所以一行可用多行表示
- 括号,括号会影响计算顺序,不会因为计算优先级而省略掉

## 注释

- /\* \*/, 块注释一般作为包注释,也会出现在描述或大块代码的disable
- // 行注释是最常见的
- godoc会从源码中收集文档,顶层声明前面的注释(中间无空行)可作为文档
- 所以文档质量的高低,就看注释的功夫
- 每个package都应该有包注释(包说明)，包注释应该在包条款前面
- 每一个要暴露的对象，都需要添加doc注释
  - doc注释,最好语句完整,长度合适
  - 第一个语句的中的第一个单词和声明对象的名字保持一致
- 注释最好是一个完整的句子，主语应该是要描述的对象
- 带因式分解的声明，注释可以抽象一点
  - 分组除了用于有关联的变量,也可用于和一个mutex绑定的一组变量

## 命名

Go中的命名很重要,甚至是作为语义的一部分.包的导出元素,首字母大写.

- 包名应该小写，不带下划线，一般不用缩写，而用单个单词,不用驼峰写法
- 包被导入之后，包名就称为了内容访问器
- 另一个约定是:包名和源码目录对应
- 尽量避免import . 除非测试
- abc包中的类型叫Writer，而不叫abcWriter
- 包暴露了多个类型时，构造方法应该是NewType1() NewType2()
- 包只暴露一个类型时，构造方法应该是New()
- 完备的文档说明比长名字的自解释要好一些,能短名字的就短一点，不行就用文档解释
  - 短名字的可读性高很多
- 变量的读取函数命名： var diy; 读Diy() 写SetDiy()，按这样的规则写,这是针对非暴露的，暴露的就无需多此一步
- 如果接口只包含一个方法，接口名应取 '方法er'
- 字符串转换方法命名为String，而不是ToString
- 单词名称命名使用峰驼记法，不要使用下划线,也不要全小写

最后,最好保持和惯例一致,比如说和标准实现类似功能,取名最好一致.

## 分号

- 源码中一般不需要出现;来表示语句结束，词法分析器会自动处理
- 分号在闭括号之前可以直接省略 eg: go func() { for { a = 1} }
- for循环子句中会出现分号，除此之外，一行中写多行语句也需要用到;
- 控制结构的左大括号{ 不能放在新行开头，只能放行未

遇到以下情况，词法分析器会自动添加;，判断依据是新行前的最后一个标记：

- 类型标识符 eg：int float64
- 基本字面量 eg：数值、字符串
- break continue fallthrough return ++ --

这是分号的插入规则,就是因为这些规则,所以控制结构的大括号不能单独一行.
另外,也就是说如果是一元运算符+-，或是逗号，都不会被认为是语句结束

## 控制结构

Go中的控制语句和C中的略有区别:

- 没有do和while语句,for语句做了扩展,包含了do和while的使用场景
- switch更加灵活
- if/switch可以像for语句一样,可以带一个初始化语句
- break/continue语句可以想goto一样,带一个标签
- 新增一个新的语句selecet,这是一个通讯复用语句
- Go语言还省略了(),强调了代码块必须用{}包裹

if/switch可以带初始化语句,可以有效控制变量的作用域.

- swith不会自动下溯(多个case使用一个执行体)，但可以将多个条件放在一个case中,逗号分割即可

## 重新声明和再次赋值

    f, err := os.open("1.txt")  // err是声明
    d, err := f.Stat()          // err是再次赋值，并非重新生成

什么情况下才是再次赋值，要满足以下条件：

- 本次声明和已声明在同一作用域 (不是同一作用域，就是新声明了)
- 赋的值要满足之前声明的类型
- 本次声明中至少有一个变量是新声明

## 函数

- 可以返回多个值
- 返回值可以命名，作用域在函数体内，会被初始化为零,和在函数内创建变量相比，好处是多了一个0初始化
- defer延时执行,多用于资源的释放,可以有多个defer函数，先出现的后执行

## for

for可以支持数组、切片、信道、map和字符串，
字符串遍历时是解析utf-8，错误的unicode将占用一个字节，
以u+fffd表示。rune就是一个unicode马点。

## type switch

接口.(type) 可以获取变量的实际类型，可以结合switch语句来做处理

## 数据

- 两种分配原语：new make
- 局部变量对应的数据在函数返回之后依然有效，这点和c不一样
- 数组赋值给数组，会复制其所有元素
- 数组当函数参数，传递的是数组副本，而不是指针
- 一般很少直接使用数组，一般使用切片来操作
- new 会将申请的内存置0，有时置0还不够，就需要用到构造函数。构造函数中可以使用复合字面量来简化。
- 复合字面量，会新申请内存的，特殊情况下复合字面量也可以不包含字段，new(Type)和&Type{} 是等价的
- 复合字面量要结合类型来看
- make 更多用于创建 切片 映射 信道，返回类型不是指针，也会初始化，不是置0操作，而是初始化其内部的数据结构
- make用于引用数据类型，new用于其他

## 数组 切片

切片是对数组的封装，提供的接口更加通用和强大，
除了矩阵变换需要明确维度，go中大部分都是使用切片，而非数组

二维数组有点特殊，特别是做图像处理时，切片分配时有两种方式:

- 独立分配每一次切片，适用于宽高会动态变化
- 只分配一个数组，切片与数组对应即可，适用于宽高固定的情况，构造效率更高

    // 切片独立分配
    pic := make([][]uint8,y)
    for i: = range pic {
        pic[i] = make([]uint8, x)
    }

    // 数组一次分配，切片对应, 使用时还是使用切片代替数组
    pic := make([][]uint8, y)
    a := make([]uint8, x * y)
    for i := range pic {
        pic[i], a = a[:x], a[x:]  // 这个写法很特别，将循环变化的因子通过再次赋值的方式来表现
    }

## map

key-value

- key可以取很多值，但不能是切片
- map和切片类似，都是引用类型。意思是都是传址。
- map可以使用复合字面量构建，键值对使用逗号分割，键值之间使用冒号分割

    var a = map[string]int {
        "a": 1,
        "b": 2,
    }

访问map中不存在的key，会返回类型对应的0值,
也可以用返回的第二个参数来判断key是否存在。

如果某个参数不关心，可以用空白标识符来表示:

    _ , ok := a["b"]  // a是一个map,_表示忽略返回值，就是一个占位符而已

map中的删除，delete(key),即使key不存在，操作也是安全的，
这点比c++好用多了。

## 打印

- fmt.Printf
- fmt.Fprintf
- fmt.Sprintf 会返回一个新的字符串，而非填充给定的缓冲

- %v，用于打印通用格式，eg：非10进制会打印成10进制，数组、结构体、map都能打印
- %+v，还会把结构体上每个字段名打出来
- %#v，按go语言语法打印出来
- %q，遇到string或[]byte时，可打印出带引号的字符串，遇到整数或rune时，
打印带单引号的
- %#q，会尽可能使用反引号
- %x，用于字符串 字节数组和整数，打印出很长的16进制字符串
- % x，中间带一个空格，打印出来的字节之间会插入空格
- %T，打印值的类型

自定义类型的默认格式，可通过String()string 方法来实现，
只需要注意String()方法中调用Sprintf时，别把类型作为string加入到格式化中，
解决方法是直接将类型实参显示转换成string。eg：

```go
    type MyString string
    func (m MyString)String()string{
        return fmt.Sprintf("MyString=%s", string(m))
        // return fmt.Sprintf("MyString=%s", m)  这种情况会导致无限递归
    }
```

func a(v ...interface{}){} // ...是告诉编译器 v是一个实参列表，
省掉就是一个具体的接口对象了。
func a(v ...int) () {} // 表示实参列表是整形

## append()

func append(slice []T, elements ...T) []T 内置的追加函数

```go
    // 适用于切片，因为底层数组有可能改变，所以写法一般是
    x := []int {1, 2, 3}
    y := []int {1, 2, 3}
    x = append(x, 4, 5, 6)

    // 切片追加切片
    x = append(x, y...) // 没有...会在编译时报类型错误
```

## 初始化

- 常量只能是数字 字符 字符串 bool。
必须是编译器可以计算出的，运行期才能计算出值的不能是常量
- 枚举是通过const实现的，和c++类似都可以从0开始，
自增，专门有个iota变量表示0,go叫这个是优雅
- 变量的值可以在运行期计算出来
- init() 每个源文件都可以有一个或多个，被称为初始化器,
一些值的初始化就可以放在里面
- atoi 字符串转整形
- itoa 整形转字符串
- iota 常量0，也有其他名称：枚举创建器

特殊的init()函数：

- 所有变量都通过init()初始化，init函数才会被调用
- 导入的包初始化完了，才会调用init函数
- init()函数除了可以做初始化，还可以用作校验程序状态

## 方法

值接收者和指针接收者的区别：

- 值方法：方法中的变更不会影响到原有的接收者，
go语言不允许这种错误，所以更多的是指针接收者
- 指针方法：会修改接收者的数据
- 值方法：可以通过指针和值调用
- 指针方法：只能通过指针调用，对此蹩脚的地方，
go规定如果接收者可以寻址，go会自动按需添加取址操作

如果是指针方法，那么a.m()和&a.m()的效果是一样的，不写&,go编译器也会自动添加。

## 接口和其他类型

- go中的接口，特指对象的行为
- 在go中，一个接口包含一到两个方法是比较常见的
- 接口名和方法名之间一般是有对应关系，io.Writer就是实现了Write功能的某些事
- 每种类型都可以实现多种接口

## 类型转换

类型转换有时是为了复用已有功能

## 接口转换 类型断言

interface.(type)是取具体的类型，interface.(string)是类型断言，判断是不是string

类型断言和switch type到底有啥不一样？

类型断言的格式是：obj,ok := 接口.(具体类型),如果接口里的数据就是这个类型的，
那么obj就是具体类型的对象，ok标识着接口里的数据是否就是指定具体类型的。

switch type，是一种特殊的组合，格式是 接口.(type),返回的是具体类型。
括号里面就是type，不是某一个类型。

这两种只是写法上的类似，而她们的作用(使用场景)是完全不同的.

## 通用性

如果一个类型实现了一个接口，并没有其他方法暴露，则说明这个类型并不需要暴露，只暴露接口即可，
这时关注更多的是接口的行为，而非实现。这种情况下构造函数应该返回一个接口类型，而不是具体类型。

```go
    // 下面是打包行为接口
    type A interface{} // 打包

    // 下面是对接口的实现
    void (a *实现1) 方法()A {} // rar打包
    void (a *实现2) 方法()A {} // zip打包

    // 打包构造应该如下
    var 打包对象 A = 实现1.方法()
    // 如果要切换到zip打包，应该是：
    var 打包对象 A = 实现2.方法()  // 这样切换不同的打包算法，只需要修改这个构造即可
```

这仅仅是将行为抽象出来，这是接口使用的一种，更加常见的是如下这种：
func 传加密数据函数(加密接口)传输接口， 而在使用时就可以自定义加密和自定义传输。
这样的好处是"传加密数据函数"是通用的，不用写多个函数(md5加密tcp传输函数、crc32加密udp传输函数)

如果一个类型，更多关注的是行为，那么可使用接口来增加通用性。

## 空白标识符

是一个占位符，

- 在for range和多重赋值中比较常见
- 除此之外，也有可能是为了包的副作用而导入的，eg：为了包的init()
    import _ "net/http/pprof" // 只使用pprof的init(),用于记录http处理程序的调试信息
- 接口检查

    if _,ok = val.(io.Reader) {} // 检查val的类型是否实现了io.Reader接口
    如果我们不想在运行过程中，自己写上面的代码去检查某类型是否实现了某接口
    也可以让编译器去检查 var _ io.Reader = (*val)(nil) 利用全局变量去检查

## 内嵌

go没有c++的类型继承体系，也没有类型驱动的子类化概念。
在结构体或接口中的内嵌，可以让新类型拥有老类型的部分实现。

- 接口的内嵌，只有接口能被嵌入到接口中，且方法集不相交
- 结构体的内嵌，内嵌类型的方法会称为外部类型的方法，调用时，接收者是内嵌类型

结构体内嵌的命名冲突：外部覆盖内部

这就是编程语言中说的：`组合优于继承`

## 并发

go的规则：线程不主动共享，要共享的值通过信道传递。
任意时刻，只有一个协程能访问该值，这样从设计上杜绝数据竞争。

这个规则换成另一句话是：不通过共享内存来通讯，而是通过通讯来共享内存。

这里的通讯是指读写值，同步是指让值的读写在同一时刻只有一个操作。
go的思想是专门弄出一个新的东西，这个东西负责读写值，其他要访问值的都通过新东西来做，
这样只要保证新东西同一时刻只有一个使用者，这样就不存在值访问竞争了。
这个新东西叫信道。

10个人吃饭，只有1双公筷，那就需要保证同一时间只有一个人得到筷子，
go中是这样的：有个服务员来拿筷子，其他人要菜时由服务员处理。
10个人对应多个线程，公筷对应资源，第一种需要程序员来控制竞争。
第二种虽然也是类似的，但程序员只需要告诉服务员就行，省了很多事，让go完成。
这个服务员(信道)是语言提供的，可能不会用到第一种中的锁，性能也应该有提升。

## 协程

go协程开销很小，只使用栈空间

go func() 就可以了 func会在后台运行

## 信道

channel 也需要通过make来申请内存，信道对象是对底层数据结构的引用。

```go
    c1 := make(chan int)        // 不带缓冲，同步信道
    c2 := make(chan int, 10)    // 缓冲信道，异步信道
```

- 同步信道，在两个协程交换数据时，保证同步
- 缓冲信道，发送者只在缓冲满了才阻塞

缓冲信道，可以作为信号量，限制吞吐量

信道的信道，是go的一大杀器

同步信道channel，最常用法(最简单用法)是等待一个后台协程处理完，返回。
缓冲信道，最常用的就是限流。同一时间最多处理几个请求。

## 并行处理

多cpu多核处理场景

go中多使用并发，可以有更多的概率触发并行

go是为并发而设计的语言，不是并行，但可以尝试解决一些并行问题，但不是全部。

## 泄露

利用缓冲信道，很容易写出导致缓冲区槽位泄露的情况

## 错误

在包中实现error接口，自定义错误信息，调试时非常有用

## 异常

内建的panic()函数会产生一个运行时错误并终止程序。

## 恢复

内建函数recover(),可在出现异常的情况下，取回程序的执行权。
