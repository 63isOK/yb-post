# go诊断

go提供了打来嗯api套件来处理逻辑问题或是性能问题。

诊断方案可分成以下几种：

- profiling：分析
  - 主要分析go程序的复杂度和消耗
  - eg：内存使用，或是函数调用频率
- tracing：跟踪
  - 是一种工具代码
  - 在调用或用户请求中的整个生命周期中，分析延时
- debugging：调试
  - 通过调试，可以暂停并分析程序的执行
  - 在调试过程中可校验程序的状态和流程
- runtime statistics and events：运行时统计和事件
  - 对运行时状态和事件的搜集和分析
  - 有助于分析吞吐量/利用率/性能的变化

这些工具尽量单独使用。

## profiling

在分析复杂度和函数的调用频率时，非常方便。
最牛的是go提供了可视化工具来查看结果。

runtime/pprof包提供了下面几种分析：

- cpu，查看cpu消耗
- heap，查看内存使用，用于分析内存泄漏
- threadcreate，创建新系统线程时进行报告
- gorotine，分析当前协程的调用栈
- block，显示同步原语中，协程阻塞在哪儿，这个默认没有启用
- mutex，分析锁，默认没有启用

还有其他可分析的工具吗

- linxu上，perf tools可以用于分析内核瓶颈
- macos上，instruments可分析go程序

具体工具的使用，后面会用文章来补充

## tracing

在一个链式调用中，分析每个函数用了多长时间，用tracing最好。

golang.org/x/net/trace。

跟踪让我们：

- 可以在go程序中测量并分析延时
- 在链式调用中，计算某个调用花了多少时间
- 分析利用率和性能调优，跟踪并不一定能很明显看到瓶颈

单进程多协程的容易跟踪，不容易跟踪的是分布式程序。
在分布式程序中，通过分析一个请求到响应的时间也是一种方法。

分布式跟踪让我们：

- 在一个大系统中进行测量并分析程序的延时
- 可以跟踪所有rpc调用
- 找出整个系统的性能提升点

go生态提供了多种和后端无关的分布式跟踪库

## debugging

调试用delve或gdb

编译时可指定不优化： go build -gcflags=all="-N -l"

支持分析core文件

## 运行时统计和事件

也是利用跟踪来实现，可用于：

- 理解协程执行
- 理解某些核心运行时事件，eg：gc
- 瓶颈分析

这篇文章主要介绍了能做什么，具体怎么做，还需要看其他文章
