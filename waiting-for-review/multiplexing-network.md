# 网络中的i/o复用

本节主要描述select和poll函数，来源是 unix网络编程卷1 3th 第6章。

## 介绍

网络应用中，i/o复用常用在：

- 处理多个描述符(unix下的文件句柄)时，必须使用i/o复用
- 一个客户同时处理多个socket，这种情况比较少见。
- 一个tcp服务既要监听socket，也要处理已连接的socket，一般使用i/o复用
- 一个服务既要处理tcp，也要处理udp，一般要用i/o复用
- 一个服务要处理多个服务/或多个协议时，需要使用i/o复用

上面仅仅是i/o复用在网络中的使用场景，其他方面的应用可查看前面的复用文档。

## i/o模型

unix下有5种i/o模型：

- 阻塞I/O
- 非阻塞I/O
- I/O复用(select,poll)
- 信号驱动式I/O (sigio)
- 异步I/O (posix系列)

网络程序怎么将网络那边的数据获取到：

- 等待数据准备好
- 网络传输，通过网卡设备接收，缓存到内核的某个缓冲区
- 把数据从内核缓冲区复制到应用进程的缓冲区

### 阻塞i/o模型

最流行的模型，默认情况所有socket都是阻塞的。

recvfrom(),接收udp数据的系统调用，执行过程如下：

- 应用程序调用recvfrom(),    用户态
- recvfrom内部调用了系统调用，等待内核准备数据  内核态
- 内核会等待数据准备好，直到将数据复制到应用程序的缓冲中  内核态
- recvfrom接收到成功提示，返回  用户态

整个过程中，recvfrom是阻塞的。
应用程序调用recvfrom时，系统会将应用程序挂起，等执行完之后，唤醒应用程序。

### 非阻塞I/O模型

如果socket被指定为非阻塞时，调用recvfrom，应用程序挂起，
内核发现socket是非阻塞的，会立马将recvfrom唤醒，此时数据还没到内核缓存区，
recvfrom会返回一个特定错误，然后应用程序可以去干其他事，内核继续等待数据。
再次调用recvfrom，如果内核发现数据已经准备好，会立马给recvfrom并返回成功。

整个过程中，recvfrom会多次调用，被称为轮询 polling。

一般不知道数据什么时候会准备好，polling会浪费大量cpu时间，所以这种模型很少见，
只出现在某些特殊的系统功能上。
