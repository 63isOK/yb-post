# 算法设计手册第二天

排序算法.

对已有数据,为啥不边读边排?  
这种做法简单可行,考虑实际环境(io消耗),在已有数据集合中排序是最高效的.

对于cpu来说,有主存和辅存,主存是ram,也叫内存;
辅存也叫外存,包含硬盘和磁带等.
内存io速度快,外存慢.硬盘称为二级存储,磁带称为三级存储,
三级存储的数据会先将数据读到二级存储,再由内存读,最后再到cpu.

就io速度来看,不同的存储,速度相差很大.
外存适合将数据存在固定大小的记录块中(白话理解是按值存);
内存支持按值存,也支持按指针存.

算法是存储无关的,只是数据放在二级存储和放在内存的性能是有差异的.

算法的稳定性是指算法执行多次的结果是一致的,
例如排序中,多个元素的值相等,排序的顺序和无序集合中的顺序是一致的,
可被认为是稳定的.稳定性中的一致,是指重复元素排序后的顺序和排序之前的顺序是一致的.

为什么排序算法的最高性能是O(nlogn)?  
除了桶排序外(桶排序不是基于元素之间的比较),
其他的排序算法都可以转换为一个二叉决策树,她的最小高度就是性能最高时,
下面是数学证明的思路:

- 二叉决策树,高度最小,意味是一个完全平衡二叉树
- n个元素,意味有n!种排序,二叉决策树的叶子节点就是n!
- 排序的最优性能就求二叉决策树的高,也就是log(n!)

下面就是计算O(log(n!)) 大于O(nlogn)的过程:

    h = log(n!) = log(n*(n-1)*(n-2)*...*2*1)
    h > log(n*(n-1)*(n-2)*...(n/2))   舍弃了一半的数据
    h > log(a) a=(n/2)的(n/2)次方     将比n/2大的都退化为n/2
    h > (n/2)log(n/2)                 利用对数公式转换
    h > (n/2)log(n) - n/2
    h > nlog(n)                       去掉常数项系数,去掉低阶项

## 插入排序

例子:斗地主启牌,抓一张牌,插入到手中已排序好的牌中.

适用场景:数据是小规模的,初始数据几乎有序.
也是要看具体规模,具体的编程语言和机器,元素类型也很重要.

基于值排序,需要移动元素且需要一个额外的存储来保存中间值;基于指针排序则不需要.
大多数语言提供的内存块移动api,是的基于值排序的算法也非常高效.

性能是O(n2), 基于值时的移动,改为块移动,会提高6倍效率.

插入排序的问题是每个元素一次移动一个位置,这种保守的算法称为本地位移排序.
