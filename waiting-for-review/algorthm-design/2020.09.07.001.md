# 算法设计手册第二天

排序算法.

对已有数据,为啥不边读边排?  
这种做法简单可行,考虑实际环境(io消耗),在已有数据集合中排序是最高效的.

对于cpu来说,有主存和辅存,主存是ram,也叫内存;
辅存也叫外存,包含硬盘和磁带等.
内存io速度快,外存慢.硬盘称为二级存储,磁带称为三级存储,
三级存储的数据会先将数据读到二级存储,再由内存读,最后再到cpu.

就io速度来看,不同的存储,速度相差很大.
外存适合将数据存在固定大小的记录块中(白话理解是按值存);
内存支持按值存,也支持按指针存.

算法是存储无关的,只是数据放在二级存储和放在内存的性能是有差异的.

算法的稳定性是指算法执行多次的结果是一致的,
例如排序中,多个元素的值相等,排序的顺序和无序集合中的顺序是一致的,
可被认为是稳定的.稳定性中的一致,是指重复元素排序后的顺序和排序之前的顺序是一致的.

为什么排序算法的最高性能是O(nlogn)?  
除了桶排序外(桶排序不是基于元素之间的比较),
其他的排序算法都可以转换为一个二叉决策树,她的最小高度就是性能最高时,
下面是数学证明的思路:

- 二叉决策树,高度最小,意味是一个完全平衡二叉树
- n个元素,意味有n!种排序,二叉决策树的叶子节点就是n!
- 排序的最优性能就求二叉决策树的高,也就是log(n!)

下面就是计算O(log(n!)) 大于O(nlogn)的过程:

    h = log(n!) = log(n*(n-1)*(n-2)*...*2*1)
    h > log(n*(n-1)*(n-2)*...(n/2))   舍弃了一半的数据
    h > log(a) a=(n/2)的(n/2)次方     将比n/2大的都退化为n/2
    h > (n/2)log(n/2)                 利用对数公式转换
    h > (n/2)log(n) - n/2
    h > nlog(n)                       去掉常数项系数,去掉低阶项

## 插入排序

例子:斗地主启牌,抓一张牌,插入到手中已排序好的牌中.

适用场景:数据是小规模的,初始数据几乎有序.
也是要看具体规模,具体的编程语言和机器,元素类型也很重要.

基于值排序,需要移动元素且需要一个额外的存储来保存中间值;基于指针排序则不需要.
大多数语言提供的内存块移动api,是的基于值排序的算法也非常高效.

性能是O(n2), 基于值时的移动,改为块移动,会提高6倍效率.

插入排序的问题是每个元素一次移动一个位置,这种保守的算法称为本地位移排序.

## 中值排序

中值排序是利用分治将问题规模减小,利用递归套用同一套算法.

这个算法的核心是如何确定中值,书中提到了一种方法来确定"第k大"的元素,
这个方法本身就是减小范围的尝试性做法,最坏的情况下这个方法的性能就退化为O(n2),
最好的是O(n).

确定中值是中值排序的第一步,后面还有分治和递归.
确定中值并不是非得是确切的中值,这样就能省掉"确定中值"的不必要消耗,
这样能保证确定中值的方法性能是O(n),之后再执行分治和递归.

说明一下,使用绝对中值,能保证切割的两个子问题规模差不多,
接下来的分治和递归都会有不错的性能,但是,"确定中值"这个过程消耗不可控,
最坏情况下,"确定中值"可能是O(n2)级别的.

其次,如果是用随机中值,"确定中值"的消耗固定为O(n),
但后续的分治和递归可能会稍差.

在最坏的情况下和平均情况下,随机都比绝对中值的性能好很多.

还有一种在最坏情况下能保证不退化到O(n2)的算法,bfprt算法(也叫top-k问题),
bfprt算法能保证"取中值"的性能在最差情况下能达到O(nlogn).

bfprt(top-k)算法的思想是:

- 将样本按4个元素切隔(bfprt算法中是5个,基准测试发现4个更快)
- 保证第三个元素是中值(这里的中值概念是绝对中值,即按中值切割,左右元素个数相差不超过1)
- 将所有的切割块中的中值作为新的样本数据,利用bfprt算法求得中值

bfprt算法就是不断将问题空间减少(递归一次,减少4倍或5倍,看按几个元素切割),
top-k是基于bfprt的一种算法,先求出中值p,再和k比较,再慢慢逼近k.
